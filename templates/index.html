<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MWI Market Trends</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@^4"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <style>
        /* --- CSS Variables for Theming --- */
        :root {
            /* Light Theme (Default) */
            --bg-color: #f8f9fa; /* Slightly off-white */
            --card-bg-color: #ffffff;
            --text-color-primary: #212529; /* Dark grey */
            --text-color-secondary: #6c757d; /* Medium grey */
            --border-color: #dee2e6; /* Light grey border */
            --accent-color: #007bff; /* Standard blue */
            --accent-hover-color: #0056b3;
            --positive-color: #28a745; /* Green */
            --negative-color: #dc3545; /* Red */
            --button-bg-color: #e9ecef;
            --button-hover-bg-color: #ced4da;
            --button-border-color: #ced4da;
            --button-hover-border-color: #adb5bd;
            --input-bg-color: #ffffff;
            --input-border-color: #ced4da;
            --input-focus-border-color: #86b7fe;
            --input-focus-shadow-color: rgba(0, 123, 255, 0.25);
            --table-header-bg: #e9ecef;
            --table-row-hover-bg: #f1f3f5;
            --table-row-selected-bg: #cfe2ff; /* Light blue selection */
            --link-color: var(--accent-color);
            --link-hover-color: var(--accent-hover-color);
            --chart-grid-color: rgba(0, 0, 0, 0.1);
            --chart-tick-color: #6c757d;
            --chart-title-color: #212529;
            --chart-tooltip-bg: rgba(0, 0, 0, 0.8);
            --chart-tooltip-text-color: #ffffff;
            --shadow-color: rgba(0, 0, 0, 0.1);
        }

        html[data-theme="dark"] {
            /* Dark Theme Overrides */
            --bg-color: #1a1a1a; /* Very dark grey */
            --card-bg-color: #2c2c2c; /* Dark grey card */
            --text-color-primary: #e9ecef; /* Light grey text */
            --text-color-secondary: #adb5bd; /* Medium grey text */
            --border-color: #495057; /* Darker border */
            --accent-color: #4dabf7; /* Lighter blue */
            --accent-hover-color: #74c0fc;
            --positive-color: #40c057; /* Lighter green */
            --negative-color: #fa5252; /* Lighter red */
            --button-bg-color: #495057;
            --button-hover-bg-color: #6c757d;
            --button-border-color: #6c757d;
            --button-hover-border-color: #adb5bd;
            --input-bg-color: #343a40;
            --input-border-color: #495057;
            --input-focus-border-color: #4dabf7;
            --input-focus-shadow-color: rgba(77, 171, 247, 0.25);
            --table-header-bg: #343a40;
            --table-row-hover-bg: #3e444a;
            --table-row-selected-bg: #364a6d; /* Darker blue selection */
            --link-color: var(--accent-color);
            --link-hover-color: var(--accent-hover-color);
            --chart-grid-color: rgba(255, 255, 255, 0.15);
            --chart-tick-color: #adb5bd;
            --chart-title-color: #e9ecef;
            --chart-tooltip-bg: rgba(255, 255, 255, 0.8);
            --chart-tooltip-text-color: #1a1a1a;
            --shadow-color: rgba(0, 0, 0, 0.3);
        }

        /* --- General Styles --- */
        *, *::before, *::after { box-sizing: border-box; }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0; padding: 0; background-color: var(--bg-color); color: var(--text-color-primary);
            line-height: 1.5; font-size: 14px;
            transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out; /* Smooth theme transition */
        }

        .container { max-width: 1600px; margin: 25px auto; padding: 0 25px; }

        h1 { text-align: center; color: var(--text-color-primary); margin-top: 1rem; margin-bottom: 0.5rem; font-weight: 600; font-size: 1.8em; letter-spacing: -0.5px; }

        .feedback-link-container { text-align: center; margin-bottom: 25px; font-size: 0.9em; }
        .feedback-link-container a { color: var(--text-color-secondary); text-decoration: none; border-bottom: 1px dashed var(--text-color-secondary); transition: color 0.2s, border-color 0.2s; padding-bottom: 1px; }
        .feedback-link-container a:hover { color: var(--link-color); border-color: var(--link-color); }

        /* --- Controls Area --- */
        .controls {
            display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center;
            padding: 16px 20px; margin-bottom: 30px; gap: 15px;
            background-color: var(--card-bg-color); border: 1px solid var(--border-color);
            border-radius: 8px; /* Slightly larger radius */
            box-shadow: 0 2px 5px var(--shadow-color);
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
        }
        .controls-left, .controls-right { display: flex; gap: 16px; align-items: center; flex-wrap: wrap; }

        /* Search and Filter Inputs */
        .search-form input[type="text"], .category-filter select {
            padding: 8px 12px; border: 1px solid var(--input-border-color); border-radius: 6px;
            min-width: 200px; font-size: 0.95em; background-color: var(--input-bg-color);
            color: var(--text-color-primary); box-shadow: inset 0 1px 2px rgba(0,0,0,0.075);
            transition: border-color 0.1s ease-in-out, box-shadow 0.1s ease-in-out, background-color 0.2s ease-in-out, color 0.2s ease-in-out;
        }
        .search-form input[type="text"]:focus, .category-filter select:focus {
            border-color: var(--input-focus-border-color);
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.075), 0 0 0 3px var(--input-focus-shadow-color);
            outline: none;
        }

        /* Buttons (General & Theme Toggle) */
        .button, #theme-toggle {
            padding: 8px 15px; background-color: var(--button-bg-color); color: var(--text-color-primary);
            border: 1px solid var(--button-border-color); border-radius: 6px; cursor: pointer;
            font-size: 0.95em; font-weight: 500; text-align: center;
            transition: background-color 0.15s ease, border-color 0.15s ease, color 0.15s ease;
            display: inline-flex; align-items: center; gap: 6px; /* For icon + text */
        }
        .button:hover, #theme-toggle:hover {
            background-color: var(--button-hover-bg-color); border-color: var(--button-hover-border-color);
        }
        #theme-toggle {
            /* Specific styles for theme toggle if needed, e.g., fixed width */
             min-width: 40px; /* Ensure enough space for icon */
             justify-content: center;
        }
        #theme-toggle .fa-sun { display: none; } /* Hide sun icon by default */
        #theme-toggle .fa-moon { display: inline-block; } /* Show moon icon by default */
        html[data-theme="dark"] #theme-toggle .fa-sun { display: inline-block; } /* Show sun in dark mode */
        html[data-theme="dark"] #theme-toggle .fa-moon { display: none; } /* Hide moon in dark mode */


        /* --- Table Styles --- */
        .table-container {
            background-color: var(--card-bg-color); border: 1px solid var(--border-color);
            border-radius: 8px; overflow: hidden; /* Needed for border-radius on table */
            box-shadow: 0 2px 5px var(--shadow-color); margin-bottom: 25px;
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
        }
        table { width: 100%; border-collapse: collapse; }
        th, td { padding: 12px 15px; text-align: left; border-bottom: 1px solid var(--border-color); }
        th {
            background-color: var(--table-header-bg); font-weight: 600; font-size: 0.9em;
            color: var(--text-color-secondary); text-transform: uppercase; letter-spacing: 0.5px;
            cursor: pointer; user-select: none; white-space: nowrap;
            transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
        }
        th .sort-icon { margin-left: 5px; color: var(--text-color-secondary); opacity: 0.6; }
        th.sorted .sort-icon { opacity: 1; color: var(--text-color-primary); }
        tbody tr { transition: background-color 0.15s ease; }
        tbody tr:hover { background-color: var(--table-row-hover-bg); }
        tbody tr.selected-row { background-color: var(--table-row-selected-bg); font-weight: 500; }
        tbody tr:last-child td { border-bottom: none; }
        td { color: var(--text-color-primary); font-size: 0.95em; transition: color 0.2s ease-in-out; }
        td.number { text-align: right; font-variant-numeric: tabular-nums; } /* Align numbers */
        td.trend { text-align: right; white-space: nowrap; }
        .trend-icon { margin-left: 4px; font-size: 0.9em; }
        .trend-positive { color: var(--positive-color); }
        .trend-negative { color: var(--negative-color); }
        .trend-neutral { color: var(--text-color-secondary); }

        /* --- Pagination --- */
        .pagination { display: flex; justify-content: center; align-items: center; padding: 15px 0; gap: 8px; }
        .pagination button {
             padding: 6px 12px; background-color: var(--button-bg-color); color: var(--text-color-primary);
             border: 1px solid var(--button-border-color); border-radius: 4px; cursor: pointer;
             font-size: 0.9em; transition: background-color 0.15s ease, border-color 0.15s ease;
        }
        .pagination button:hover:not(:disabled) { background-color: var(--button-hover-bg-color); border-color: var(--button-hover-border-color); }
        .pagination button:disabled { opacity: 0.5; cursor: not-allowed; }
        .pagination span { font-size: 0.9em; color: var(--text-color-secondary); margin: 0 5px; }

        /* --- Chart Area --- */
        .chart-container {
            background-color: var(--card-bg-color); border: 1px solid var(--border-color);
            border-radius: 8px; padding: 20px; margin-bottom: 30px;
            box-shadow: 0 2px 5px var(--shadow-color);
            transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;
        }
        .chart-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; flex-wrap: wrap; gap: 10px;}
        .chart-title { font-size: 1.1em; font-weight: 600; color: var(--text-color-primary); transition: color 0.2s ease-in-out; }
        .chart-controls button {
             padding: 5px 10px; background-color: var(--button-bg-color); color: var(--text-color-primary);
             border: 1px solid var(--button-border-color); border-radius: 4px; cursor: pointer;
             font-size: 0.85em; transition: background-color 0.15s ease, border-color 0.15s ease;
        }
        .chart-controls button:hover { background-color: var(--button-hover-bg-color); border-color: var(--button-hover-border-color); }
        .chart-controls button.active { background-color: var(--accent-color); color: white; border-color: var(--accent-color); }
        #priceChart { max-height: 400px; } /* Limit chart height */

        /* --- Footer --- */
        footer { text-align: center; margin-top: 40px; padding: 20px; font-size: 0.85em; color: var(--text-color-secondary); border-top: 1px solid var(--border-color); transition: color 0.2s ease-in-out, border-color 0.2s ease-in-out; }
        footer a { color: var(--link-color); text-decoration: none; }
        footer a:hover { text-decoration: underline; color: var(--link-hover-color); }

        /* --- Utility --- */
        .loading-indicator, .error-message { text-align: center; padding: 40px; font-size: 1.1em; color: var(--text-color-secondary); }
        .hidden { display: none; } /* Simple hide utility */

        /* Responsive adjustments if needed */
        @media (max-width: 768px) {
            .controls { flex-direction: column; align-items: stretch; }
            .controls-left, .controls-right { width: 100%; justify-content: center; }
            .search-form input[type="text"], .category-filter select { width: 100%; min-width: unset; }
            .chart-header { flex-direction: column; align-items: flex-start; }
            th, td { padding: 8px 10px; font-size: 0.9em;} /* Smaller padding on mobile */
            h1 { font-size: 1.5em; }
        }

    </style>
</head>
<body>
    <div class="container">
        <h1>Milky Way Idle Market Trends</h1>
        <div class="feedback-link-container">
             <a href="https://github.com/sporky/market-tracker-mwi/issues" target="_blank" rel="noopener noreferrer">Report an Issue / Feedback</a>
        </div>

        <div class="controls">
            <div class="controls-left">
                <form class="search-form" id="search-form" onsubmit="event.preventDefault();">
                    <input type="text" id="search-input" placeholder="Search item name...">
                </form>
                <div class="category-filter">
                    <select id="category-select">
                        <option value="">All Categories</option>
                        {% for category in categories %}
                        <option value="{{ category }}">{{ category }}</option>
                        {% endfor %}
                    </select>
                </div>
            </div>
            <div class="controls-right">
                 <button id="theme-toggle" title="Toggle Theme">
                     <i class="fas fa-moon"></i> <i class="fas fa-sun"></i>  </button>
                 </div>
        </div>

        <div class="chart-container">
            <div class="chart-header">
                <div id="chart-title" class="chart-title">Select an item to view price history</div>
                <div class="chart-controls" id="chart-controls">
                    <button data-range="24h" class="active">24h</button>
                    <button data-range="48h">48h</button>
                    <button data-range="7d">7d</button>
                    <button data-range="30d">30d</button>
                </div>
            </div>
            <canvas id="priceChart"></canvas>
            <div id="chart-loading" class="loading-indicator hidden">Loading chart data...</div>
            <div id="chart-error" class="error-message hidden">Could not load chart data.</div>
        </div>

        <div class="table-container">
            <table id="market-table">
                <thead>
                    <tr>
                        <th data-sort="name">Name <span class="sort-icon fas fa-sort"></span></th>
                        <th data-sort="category">Category <span class="sort-icon fas fa-sort"></span></th>
                        <th data-sort="buy" class="number">Buy Price <span class="sort-icon fas fa-sort"></span></th>
                        <th data-sort="ask" class="number">Ask Price <span class="sort-icon fas fa-sort"></span></th>
                        <th data-sort="vendor" class="number">Vendor <span class="sort-icon fas fa-sort"></span></th>
                        <th data-sort="trend" class="number">24h Trend <span class="sort-icon fas fa-sort"></span></th>
                    </tr>
                </thead>
                <tbody id="market-body">
                    </tbody>
            </table>
            <div id="table-loading" class="loading-indicator">Loading market data...</div>
            <div id="table-error" class="error-message hidden">Could not load market data.</div>
            <div id="no-results" class="error-message hidden">No items match your search/filter.</div>
        </div>

        <div class="pagination" id="pagination">
            </div>

        <footer>
            Data generated: <span id="last-update">{{ last_update }}</span> |
            Created by Sporky with AI |
            Data source: <a href="https://github.com/holychikenz/MWIApi" target="_blank" rel="noopener noreferrer">holychikenz/MWIApi</a>
        </footer>
    </div>

    <script>
        // --- Constants and State ---
        const ITEMS_PER_PAGE = 20;
        let allItems = []; // Holds all fetched item data
        let filteredItems = []; // Holds items after search/filter
        let sortedItems = []; // Holds items after sorting
        let currentPage = 1;
        let currentSort = { column: 'name', direction: 'asc' }; // Default sort
        let selectedItem = null; // Name of the item selected for charting
        let priceChart = null; // Chart.js instance
        let historicalDataCache = {}; // Cache for fetched historical data {itemName: data}
        let currentChartRange = '24h'; // Default chart range

        // --- DOM Elements ---
        const tableBody = document.getElementById('market-body');
        const paginationContainer = document.getElementById('pagination');
        const searchInput = document.getElementById('search-input');
        const categorySelect = document.getElementById('category-select');
        const tableLoading = document.getElementById('table-loading');
        const tableError = document.getElementById('table-error');
        const noResults = document.getElementById('no-results');
        const chartCanvas = document.getElementById('priceChart').getContext('2d');
        const chartTitle = document.getElementById('chart-title');
        const chartControls = document.getElementById('chart-controls');
        const chartLoading = document.getElementById('chart-loading');
        const chartError = document.getElementById('chart-error');
        const themeToggleButton = document.getElementById('theme-toggle'); // Theme toggle button

        // --- Theme Switching Logic ---
        const THEME_KEY = 'mwi-market-theme';

        function applyTheme(theme) {
            if (theme === 'dark') {
                document.documentElement.setAttribute('data-theme', 'dark');
            } else {
                document.documentElement.removeAttribute('data-theme');
            }
            localStorage.setItem(THEME_KEY, theme);
            // Update chart colors if chart exists
            if (priceChart) {
                updateChartTheme();
            }
        }

        function toggleTheme() {
            const currentTheme = document.documentElement.hasAttribute('data-theme') ? 'dark' : 'light';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            applyTheme(newTheme);
        }

        function initTheme() {
            const savedTheme = localStorage.getItem(THEME_KEY);
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            const initialTheme = savedTheme || (prefersDark ? 'dark' : 'light');
            applyTheme(initialTheme);
        }

        // Add event listener for the theme toggle button
        themeToggleButton.addEventListener('click', toggleTheme);

        // Initialize theme on load
        document.addEventListener('DOMContentLoaded', initTheme);


        // --- Data Fetching ---
        async function fetchData() {
            tableLoading.classList.remove('hidden');
            tableError.classList.add('hidden');
            noResults.classList.add('hidden');
            tableBody.innerHTML = ''; // Clear table while loading
            paginationContainer.innerHTML = ''; // Clear pagination

            try {
                const response = await fetch('./data/market_summary.json?t=' + Date.now()); // Cache bust
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                allItems = await response.json();
                // Initial processing
                filteredItems = [...allItems];
                sortItems(); // Apply default sort
                renderTablePage();
                renderPagination();
                tableLoading.classList.add('hidden');

            } catch (error) {
                console.error("Failed to fetch market data:", error);
                tableLoading.classList.add('hidden');
                tableError.textContent = `Error loading market data: ${error.message}. Please try again later.`;
                tableError.classList.remove('hidden');
            }
        }

        async function fetchHistoricalData(itemName) {
            if (historicalDataCache[itemName]) {
                return historicalDataCache[itemName];
            }
            chartLoading.classList.remove('hidden');
            chartError.classList.add('hidden');
            try {
                // Use a cache-busting query parameter
                const response = await fetch(`./data/market_history.json?t=${Date.now()}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const allHistory = await response.json();
                if (!allHistory[itemName]) {
                     console.warn(`No historical data found for ${itemName} in market_history.json`);
                     historicalDataCache[itemName] = { buy: [], ask: [] }; // Cache empty data
                     chartLoading.classList.add('hidden');
                     chartError.textContent = `No historical data available for ${itemName}.`;
                     chartError.classList.remove('hidden');
                     return historicalDataCache[itemName];
                }
                // Convert timestamps (seconds since epoch) to Date objects for Chart.js
                const parseHistory = (history) => history.map(p => ({ x: new Date(p.timestamp * 1000), y: p.price }));
                const itemData = {
                    buy: parseHistory(allHistory[itemName].buy || []),
                    ask: parseHistory(allHistory[itemName].ask || [])
                };
                historicalDataCache[itemName] = itemData; // Cache the data
                chartLoading.classList.add('hidden');
                return itemData;
            } catch (error) {
                console.error(`Failed to fetch historical data for ${itemName}:`, error);
                chartLoading.classList.add('hidden');
                chartError.textContent = `Error loading chart data for ${itemName}.`;
                chartError.classList.remove('hidden');
                return null; // Indicate error
            }
        }


        // --- Data Filtering and Sorting ---
        function filterAndSort() {
            // 1. Filter by search term
            const searchTerm = searchInput.value.toLowerCase().trim();
            let tempItems = allItems;
            if (searchTerm) {
                tempItems = tempItems.filter(item => item.name.toLowerCase().includes(searchTerm));
            }

            // 2. Filter by category
            const selectedCategory = categorySelect.value;
            if (selectedCategory) {
                tempItems = tempItems.filter(item => item.category === selectedCategory);
            }
            filteredItems = tempItems;

            // 3. Sort
            sortItems();

            // 4. Reset to page 1 and re-render
            currentPage = 1;
            renderTablePage();
            renderPagination();

             // Show 'no results' message if applicable
            noResults.classList.toggle('hidden', filteredItems.length > 0);
            // Hide/show table container based on results
            document.querySelector('.table-container').classList.toggle('hidden', filteredItems.length === 0);
            paginationContainer.classList.toggle('hidden', filteredItems.length === 0);
        }

        function sortItems() {
            const { column, direction } = currentSort;
            sortedItems = [...filteredItems].sort((a, b) => {
                let valA = a[column];
                let valB = b[column];

                // Handle null/undefined values (e.g., vendor price -1 becomes null)
                // Treat nulls as lowest value for sorting purposes
                if (valA === null || valA === undefined) valA = direction === 'asc' ? -Infinity : Infinity;
                if (valB === null || valB === undefined) valB = direction === 'asc' ? -Infinity : Infinity;

                // Handle numeric vs string comparison
                if (typeof valA === 'number' && typeof valB === 'number') {
                    return direction === 'asc' ? valA - valB : valB - valA;
                } else {
                    // Ensure consistent string comparison (case-insensitive)
                    valA = String(valA).toLowerCase();
                    valB = String(valB).toLowerCase();
                    if (valA < valB) return direction === 'asc' ? -1 : 1;
                    if (valA > valB) return direction === 'asc' ? 1 : -1;
                    return 0;
                }
            });
        }

        function handleSort(event) {
            const newColumn = event.target.closest('th').dataset.sort;
            if (!newColumn) return; // Clicked outside a sortable header

            let newDirection = 'asc';
            if (currentSort.column === newColumn && currentSort.direction === 'asc') {
                newDirection = 'desc';
            }

            currentSort = { column: newColumn, direction: newDirection };
            sortItems(); // Re-sort the currently filtered items
            currentPage = 1; // Go back to page 1 after sorting
            renderTablePage();
            renderPagination(); // Pagination might change if sorting affects order significantly (though usually not item count)
            updateSortIcons();
        }

        function updateSortIcons() {
            document.querySelectorAll('#market-table th[data-sort]').forEach(th => {
                const column = th.dataset.sort;
                const icon = th.querySelector('.sort-icon');
                th.classList.remove('sorted');
                icon.className = 'sort-icon fas fa-sort'; // Reset icon

                if (column === currentSort.column) {
                    th.classList.add('sorted');
                    icon.className = `sort-icon fas ${currentSort.direction === 'asc' ? 'fa-sort-up' : 'fa-sort-down'}`;
                }
            });
        }

        // --- Rendering ---
        function renderTablePage() {
            tableBody.innerHTML = ''; // Clear previous page
            const start = (currentPage - 1) * ITEMS_PER_PAGE;
            const end = start + ITEMS_PER_PAGE;
            const pageItems = sortedItems.slice(start, end);

            if (pageItems.length === 0 && allItems.length > 0) {
                 // Handled by the 'no-results' div toggle in filterAndSort
                return;
            }

            const fragment = document.createDocumentFragment();
            pageItems.forEach(item => {
                const row = document.createElement('tr');
                row.dataset.itemName = item.name; // Store item name for chart selection
                row.classList.toggle('selected-row', item.name === selectedItem); // Highlight if selected

                // Trend display
                let trendHtml = '<span class="trend-neutral">-</span>'; // Default: neutral
                if (typeof item.trend === 'number' && !isNaN(item.trend)) {
                    const trendClass = item.trend > 0 ? 'trend-positive' : (item.trend < 0 ? 'trend-negative' : 'trend-neutral');
                    const trendIcon = item.trend > 0 ? 'fa-arrow-up' : (item.trend < 0 ? 'fa-arrow-down' : '');
                    trendHtml = `<span class="${trendClass}">${item.trend.toFixed(1)}% ${trendIcon ? `<i class="fas ${trendIcon} trend-icon"></i>` : ''}</span>`;
                }

                // Format numbers nicely, handle nulls gracefully
                const formatPrice = (price) => (price === null || price === undefined) ? '-' : price.toLocaleString();

                row.innerHTML = `
                    <td>${item.name}</td>
                    <td>${item.category || 'N/A'}</td>
                    <td class="number">${formatPrice(item.buy)}</td>
                    <td class="number">${formatPrice(item.ask)}</td>
                    <td class="number">${item.vendor === null ? '-' : formatPrice(item.vendor)}</td>
                    <td class="trend number">${trendHtml}</td>
                `;
                // Add click listener for chart selection
                row.addEventListener('click', handleRowClick);
                fragment.appendChild(row);
            });
            tableBody.appendChild(fragment);
        }

        function renderPagination() {
            paginationContainer.innerHTML = ''; // Clear previous controls
            const totalPages = Math.ceil(sortedItems.length / ITEMS_PER_PAGE);

            if (totalPages <= 1) return; // No pagination needed for 0 or 1 page

            const fragment = document.createDocumentFragment();

            // Previous Button
            const prevButton = document.createElement('button');
            prevButton.innerHTML = '&laquo; Prev';
            prevButton.disabled = currentPage === 1;
            prevButton.addEventListener('click', () => {
                if (currentPage > 1) {
                    currentPage--;
                    renderTablePage();
                    renderPagination(); // Re-render to update button states
                }
            });
            fragment.appendChild(prevButton);

            // Page Info Span
            const pageInfo = document.createElement('span');
            pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
            fragment.appendChild(pageInfo);

            // Next Button
            const nextButton = document.createElement('button');
            nextButton.innerHTML = 'Next &raquo;';
            nextButton.disabled = currentPage === totalPages;
            nextButton.addEventListener('click', () => {
                if (currentPage < totalPages) {
                    currentPage++;
                    renderTablePage();
                    renderPagination(); // Re-render to update button states
                }
            });
            fragment.appendChild(nextButton);

            paginationContainer.appendChild(fragment);
        }

        // --- Charting ---

        // Function to get computed style for theme-aware colors
        function getCssVariable(varName) {
            return getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
        }

        function getChartColors() {
             // Use CSS variables defined in the <style> block
            return {
                buyColor: getCssVariable('--positive-color') || 'rgba(40, 167, 69, 0.8)', // Greenish
                askColor: getCssVariable('--negative-color') || 'rgba(220, 53, 69, 0.8)', // Reddish
                gridColor: getCssVariable('--chart-grid-color') || 'rgba(0, 0, 0, 0.1)',
                tickColor: getCssVariable('--chart-tick-color') || '#6c757d',
                titleColor: getCssVariable('--chart-title-color') || '#212529',
                tooltipBgColor: getCssVariable('--chart-tooltip-bg') || 'rgba(0, 0, 0, 0.8)',
                tooltipTextColor: getCssVariable('--chart-tooltip-text-color') || '#ffffff'
            };
        }

         function createOrUpdateChart(itemName, historyData) {
            if (!historyData || (!historyData.buy.length && !historyData.ask.length)) {
                 chartTitle.textContent = `No price history available for ${itemName}`;
                 if (priceChart) {
                     priceChart.destroy();
                     priceChart = null;
                 }
                 return;
            }

            chartTitle.textContent = `Price History: ${itemName}`;
            const colors = getChartColors();

            const datasets = [
                {
                    label: 'Buy Price',
                    data: historyData.buy,
                    borderColor: colors.buyColor,
                    backgroundColor: colors.buyColor, // For points/fill if needed
                    tension: 0.1, // Slight smoothing
                    pointRadius: 1, // Smaller points
                    pointHoverRadius: 4,
                    borderWidth: 1.5,
                },
                {
                    label: 'Ask Price',
                    data: historyData.ask,
                    borderColor: colors.askColor,
                    backgroundColor: colors.askColor,
                    tension: 0.1,
                    pointRadius: 1,
                    pointHoverRadius: 4,
                    borderWidth: 1.5,
                }
            ];

            // Filter data based on the selected time range
            const now = new Date();
            let minTime;
            switch (currentChartRange) {
                case '48h': minTime = new Date(now.getTime() - 48 * 60 * 60 * 1000); break;
                case '7d': minTime = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000); break;
                case '30d': minTime = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000); break;
                case '24h': // fallthrough default
                default: minTime = new Date(now.getTime() - 24 * 60 * 60 * 1000); break;
            }

            const filteredDatasets = datasets.map(ds => ({
                ...ds,
                data: ds.data.filter(point => point.x >= minTime)
            }));


            const chartConfig = {
                type: 'line',
                data: { datasets: filteredDatasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: determineTimeUnit(minTime, now), // Auto unit based on range
                                tooltipFormat: 'MMM d, yyyy HH:mm', // More detailed tooltip
                                displayFormats: { // Sensible display formats
                                    millisecond: 'HH:mm:ss.SSS',
                                    second: 'HH:mm:ss',
                                    minute: 'HH:mm',
                                    hour: 'MMM d HH:mm',
                                    day: 'MMM d',
                                    week: 'MMM d',
                                    month: 'MMM yyyy',
                                    quarter: 'QQQ yyyy',
                                    year: 'yyyy',
                                }
                            },
                            grid: { color: colors.gridColor },
                            ticks: { color: colors.tickColor, maxRotation: 0, autoSkip: true, maxTicksLimit: 10 }, // Limit ticks
                            title: { display: true, text: 'Time', color: colors.titleColor }
                        },
                        y: {
                            type: 'logarithmic', // Use logarithmic scale
                             grid: { color: colors.gridColor },
                            ticks: {
                                color: colors.tickColor,
                                // Use a callback to format ticks in a more readable way (e.g., 1k, 1M)
                                callback: function(value, index, values) {
                                    if (value >= 1000000) return (value / 1000000) + 'M';
                                    if (value >= 1000) return (value / 1000) + 'k';
                                    return value.toLocaleString(); // Standard formatting for smaller numbers
                                }
                            },
                            title: { display: true, text: 'Price (Log Scale)', color: colors.titleColor },
                            afterBuildTicks: (axis) => { // Prevent zero/negative ticks on log scale
                                axis.ticks = axis.ticks.filter(tick => tick.value > 0);
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            mode: 'index', // Show tooltips for all datasets at the same x-index
                            intersect: false, // Show even if not directly hovering over point
                            backgroundColor: colors.tooltipBgColor,
                            titleColor: colors.tooltipTextColor,
                            bodyColor: colors.tooltipTextColor,
                        },
                        legend: {
                            labels: { color: colors.titleColor } // Use title color for legend text
                        }
                    },
                    interaction: {
                        mode: 'nearest', // Better interaction modes
                        axis: 'x',
                        intersect: false
                    },
                    animation: { duration: 300 }, // Faster animation
                }
            };

            if (priceChart) {
                priceChart.data.datasets = filteredDatasets; // Update data
                priceChart.options.scales.x.time.unit = determineTimeUnit(minTime, now); // Update time unit
                priceChart.options.scales.x.grid.color = colors.gridColor;
                priceChart.options.scales.x.ticks.color = colors.tickColor;
                priceChart.options.scales.x.title.color = colors.titleColor;
                priceChart.options.scales.y.grid.color = colors.gridColor;
                priceChart.options.scales.y.ticks.color = colors.tickColor;
                priceChart.options.scales.y.title.color = colors.titleColor;
                priceChart.options.plugins.tooltip.backgroundColor = colors.tooltipBgColor;
                priceChart.options.plugins.tooltip.titleColor = colors.tooltipTextColor;
                priceChart.options.plugins.tooltip.bodyColor = colors.tooltipTextColor;
                priceChart.options.plugins.legend.labels.color = colors.titleColor;
                // Update dataset colors directly
                priceChart.data.datasets[0].borderColor = colors.buyColor;
                priceChart.data.datasets[0].backgroundColor = colors.buyColor;
                priceChart.data.datasets[1].borderColor = colors.askColor;
                priceChart.data.datasets[1].backgroundColor = colors.askColor;
                priceChart.update();
            } else {
                priceChart = new Chart(chartCanvas, chartConfig);
            }
        }

        // Helper to determine appropriate time unit for x-axis based on range
        function determineTimeUnit(minTime, maxTime) {
            const diffHours = (maxTime - minTime) / (1000 * 60 * 60);
            if (diffHours <= 48) return 'hour';
            if (diffHours <= 7 * 24) return 'day';
            return 'day'; // Default to day for longer ranges
        }

        function updateChartTheme() {
            if (!priceChart) return;
            const colors = getChartColors();
            // Update colors in options
            priceChart.options.scales.x.grid.color = colors.gridColor;
            priceChart.options.scales.x.ticks.color = colors.tickColor;
            priceChart.options.scales.x.title.color = colors.titleColor;
            priceChart.options.scales.y.grid.color = colors.gridColor;
            priceChart.options.scales.y.ticks.color = colors.tickColor;
            priceChart.options.scales.y.title.color = colors.titleColor;
            priceChart.options.plugins.tooltip.backgroundColor = colors.tooltipBgColor;
            priceChart.options.plugins.tooltip.titleColor = colors.tooltipTextColor;
            priceChart.options.plugins.tooltip.bodyColor = colors.tooltipTextColor;
            priceChart.options.plugins.legend.labels.color = colors.titleColor;
            // Update dataset colors directly
            priceChart.data.datasets[0].borderColor = colors.buyColor;
            priceChart.data.datasets[0].backgroundColor = colors.buyColor;
            priceChart.data.datasets[1].borderColor = colors.askColor;
            priceChart.data.datasets[1].backgroundColor = colors.askColor;

            priceChart.update(); // Re-render the chart with new colors
        }


        // --- Event Handlers ---
        async function handleRowClick(event) {
            const row = event.currentTarget;
            const itemName = row.dataset.itemName;

            if (selectedItem === itemName) return; // Don't reload if clicking the same item

            // Update selected item state
            selectedItem = itemName;

            // Update row highlighting
            document.querySelectorAll('#market-body tr.selected-row').forEach(r => r.classList.remove('selected-row'));
            row.classList.add('selected-row');

            // Fetch and display chart data
            const historyData = await fetchHistoricalData(itemName);
            if (historyData) { // Only update chart if data fetch was successful
                 createOrUpdateChart(itemName, historyData);
            } else {
                 // Error handled within fetchHistoricalData, maybe clear chart?
                 if (priceChart) {
                     priceChart.destroy();
                     priceChart = null;
                 }
                 chartTitle.textContent = `Could not load data for ${itemName}`;
            }
        }

        function handleChartRangeChange(event) {
            if (event.target.tagName !== 'BUTTON') return; // Ignore clicks not on buttons

            const newRange = event.target.dataset.range;
            if (newRange === currentChartRange) return; // No change

            currentChartRange = newRange;

            // Update button active state
            chartControls.querySelectorAll('button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.range === newRange);
            });

            // Re-fetch or re-filter and update chart if an item is selected
            if (selectedItem) {
                const cachedData = historicalDataCache[selectedItem];
                if (cachedData) { // Use cached data if available
                    createOrUpdateChart(selectedItem, cachedData);
                } else {
                    // This case should ideally not happen if row click fetches first,
                    // but as a fallback, we could re-trigger fetch.
                    fetchHistoricalData(selectedItem).then(historyData => {
                         if (historyData) createOrUpdateChart(selectedItem, historyData);
                    });
                }
            }
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            // Initial data fetch
            fetchData();

            // Add event listeners
            searchInput.addEventListener('input', filterAndSort);
            categorySelect.addEventListener('change', filterAndSort);
            document.querySelector('#market-table thead').addEventListener('click', handleSort);
            chartControls.addEventListener('click', handleChartRangeChange);

            // Initial sort icon update
            updateSortIcons();

            // Note: Theme initialization is handled by its own DOMContentLoaded listener earlier
        });

    </script>
</body>
</html>
