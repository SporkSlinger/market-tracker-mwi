<!DOCTYPE html>
<html lang="en"> <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MWI Market Trends</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@^4"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer" />

    <style>
        /* --- Original Styling --- */
        /* Base variables (can be used if desired, but not modifying original rules to use them extensively) */
        :root {
            --accent-color-light: #0969da;
            --accent-hover-color-light: #0550ae;
            --positive-color-light: #1a7f37;
            --negative-color-light: #cf222e;
            --border-color-light: #d0d7de;
            --link-color-light: var(--accent-color-light);
            --link-hover-color-light: var(--accent-hover-color-light);
            --muted-text-color-light: #57606a;
            --code-font: SFMono-Regular, Consolas, "Liberation Mono", Menlo, Courier, monospace;
        }

        *, *::before, *::after { box-sizing: border-box; }
        body {
            font-family: 'Inter', sans-serif; margin: 0; padding: 0;
            background-color: #f6f8fa; /* Original hardcoded */
            color: #24292f; /* Original hardcoded */
            line-height: 1.5; font-size: 14px;
            transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;
            padding-bottom: 80px; /* Add padding for fixed button */
        }
        .container { max-width: 1600px; margin: 25px auto; padding: 0 25px; }
        h1 { text-align: center; color: #24292f; margin-top: 1rem; margin-bottom: 0.5rem; font-weight: 600; font-size: 1.8em; letter-spacing: -0.5px; }
        .feedback-link-container { text-align: center; margin-bottom: 25px; font-size: 0.9em; }
        .feedback-link-container a { color: #57606a; text-decoration: none; border-bottom: 1px dashed #57606a; transition: color 0.2s, border-color 0.2s; padding-bottom: 1px; }
        .feedback-link-container a:hover { color: var(--link-color-light); border-color: var(--link-color-light); } /* Use var for link hover */
        .controls { display: flex; flex-wrap: wrap; justify-content: space-between; align-items: center; padding: 16px 20px; margin-bottom: 30px; gap: 15px; background-color: #fcfcfd; border: 1px solid #d0d7de; border-radius: 6px; transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;}
        .controls-left, .controls-right { display: flex; gap: 16px; align-items: center; flex-wrap: wrap; }
        .search-form input[type="text"], .category-filter select { padding: 8px 12px; border: 1px solid #d0d7de; border-radius: 6px; min-width: 200px; font-size: 0.95em; background-color: #ffffff; box-shadow: inset 0 1px 0 rgba(27,31,36,0.075); transition: border-color 0.1s ease-in-out, box-shadow 0.1s ease-in-out, background-color 0.2s ease-in-out, color 0.2s ease-in-out; color: #24292f;}
        .search-form input[type="text"]:focus, .category-filter select:focus { border-color: var(--accent-color-light); box-shadow: inset 0 1px 0 rgba(27,31,36,0.075), 0 0 0 3px rgba(9, 105, 218, 0.3); outline: none; }
        .sort-options span { font-weight: 600; color: #57606a; margin-right: 4px; font-size: 0.9em; }
        .sort-options button { padding: 5px 12px; background-color: #f6f8fa; color: #24292f; border-radius: 6px; font-size: 0.9em; transition: background-color 0.1s ease-in-out, border-color 0.1s ease-in-out; border: 1px solid rgba(27, 31, 36, 0.15); box-shadow: 0 1px 0 rgba(27, 31, 36, 0.04); cursor: pointer; font-weight: 500; line-height: 20px; }
        .sort-options button:hover { background-color: #f0f2f4; border-color: rgba(27, 31, 36, 0.35); }
        .sort-options button.current-sort { background-color: var(--accent-color-light); color: white; border-color: var(--accent-color-light); font-weight: 600; }
        .main-layout { display: flex; flex-wrap: wrap; gap: 25px; }
        .item-table-container { flex: 3; min-width: 550px; }
        .chart-display-container { flex: 2; min-width: 400px; }
        .table-wrapper { max-height: 78vh; overflow-y: auto; border: 1px solid #d0d7de; border-radius: 6px; background-color: #ffffff; transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;}
        #item-table { width: 100%; border-collapse: collapse; }
        #item-table th, #item-table td { padding: 10px 14px; text-align: left; border-bottom: 1px solid #d0d7de; white-space: nowrap; vertical-align: middle; font-size: 0.95em; }
        #item-table th { background-color: #f6f8fa; font-weight: 600; font-size: 0.8em; text-transform: uppercase; letter-spacing: 0.5px; color: #57606a; position: sticky; top: 0; z-index: 1; transition: background-color 0.2s ease-in-out, color 0.2s ease-in-out;}
        #item-table tbody tr { transition: background-color 0.15s ease; }
        #item-table tbody tr:nth-child(even) { background-color: #fbfcfd; }
        #item-table tbody tr:hover { background-color: #f6f8fa; }
        #item-table tbody tr.selected-item { background-color: #ddf4ff; font-weight: 500; }
        #item-table td:nth-child(1) { font-weight: 500; cursor: pointer; color: var(--link-color-light); max-width: 220px; overflow: hidden; text-overflow: ellipsis; }
        #item-table td:nth-child(1):hover { text-decoration: underline; color: var(--link-hover-color-light); }
        #item-table td:nth-child(2) { font-size: 0.9em; color: #57606a; max-width: 160px; overflow: hidden; text-overflow: ellipsis; }
        #item-table td:nth-child(n+3) { text-align: right; font-family: var(--code-font); font-size: 0.95em; }
        .trend-value-container { display: flex; align-items: center; justify-content: flex-end; gap: 3px; }
        .trend-icon { width: 14px; height: 14px; vertical-align: text-bottom; }
        .trend-positive { color: var(--positive-color-light); }
        .trend-negative { color: var(--negative-color-light); }
        .vendor-price { color: #57606a; }
        .na-value { color: #cdd4de; font-style: normal; }
        .chart-display { background-color: #ffffff; border: 1px solid #d0d7de; border-radius: 6px; padding: 20px; min-height: 450px; position: relative; display: flex; flex-direction: column; transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out;}
        .chart-controls { text-align: center; margin-bottom: 15px; }
        .chart-controls button { margin: 0 4px; padding: 5px 10px; font-size: 0.85em; background-color: #f6f8fa; border: 1px solid rgba(27, 31, 36, 0.15); box-shadow: 0 1px 0 rgba(27, 31, 36, 0.04); border-radius: 6px; cursor: pointer; transition: background-color 0.1s ease-in-out, border-color 0.1s ease-in-out; font-weight: 500; color: #24292f;}
        .chart-controls button:hover { background-color: #f0f2f4; border-color: rgba(27, 31, 36, 0.35); }
        .chart-controls button.active { background-color: var(--accent-color-light); color: white; border-color: var(--accent-color-light); font-weight: 600; }
        .chart-placeholder { text-align: center; color: #b0b8c2; padding: 60px; font-size: 1.05em; flex-grow: 1; display: flex; align-items: center; justify-content: center; }
        .chart-plot { flex-grow: 1; position: relative; min-height: 320px; }
        .chart-plot canvas { max-width: 100%; max-height: 380px; }
        .pagination { text-align: center; margin-top: 20px; padding-bottom: 20px; }
        .pagination button { margin: 0 3px; padding: 7px 14px; background-color: #f6f8fa; border: 1px solid rgba(27, 31, 36, 0.15); box-shadow: 0 1px 0 rgba(27, 31, 36, 0.04); color: var(--accent-color-light); border-radius: 6px; transition: background-color 0.1s, border-color 0.1s; cursor: pointer; font-weight: 500; font-size: 0.9em; }
        .pagination button:hover:not(:disabled) { background-color: #f1f3f5; border-color: #adb5bd; }
        .pagination button.current { background-color: var(--accent-color-light); color: white; border-color: var(--accent-color-light); font-weight: bold; cursor: default; }
        .pagination button:disabled { color: #8c959f; background-color: #f6f8fa; cursor: not-allowed; border-color: transparent; }
        .loading-message, .error-message { text-align: center; padding: 40px; font-size: 1.1em; color: #57606a; }
        .error-message { color: var(--negative-color-light); }
        .hidden { display: none; }
        footer { text-align: center; margin-top: 60px; padding: 25px 0; font-size: 0.8em; color: #57606a; border-top: 1px solid #d0d7de; transition: color 0.2s ease-in-out, border-color 0.2s ease-in-out;}
        footer span, footer a { margin: 0 8px; color: #57606a; text-decoration: none; }
        footer a:hover { text-decoration: underline; color: var(--link-hover-color-light); }
         @media (max-width: 768px) {
            .controls { flex-direction: column; align-items: stretch; }
            .controls-left, .controls-right { width: 100%; justify-content: center; }
            .search-form input[type="text"], .category-filter select { width: 100%; min-width: unset; }
            .main-layout { flex-direction: column; }
            .item-table-container, .chart-display-container { min-width: unset; }
            .table-wrapper { max-height: 60vh; }
            h1 { font-size: 1.5em; }
            .theme-toggle-container { bottom: 10px; } /* Adjust position */
        }

        /* --- Dark Mode Overrides (Added) --- */
        html[data-theme="dark"] body { background-color: #0d1117; color: #c9d1d9; }
        html[data-theme="dark"] h1 { color: #c9d1d9; }
        html[data-theme="dark"] .feedback-link-container a { color: #8b949e; border-color: #8b949e; }
        html[data-theme="dark"] .feedback-link-container a:hover { color: #58a6ff; border-color: #58a6ff; }
        html[data-theme="dark"] .controls { background-color: #161b22; border-color: #30363d; }
        html[data-theme="dark"] .search-form input[type="text"],
        html[data-theme="dark"] .category-filter select { border-color: #30363d; background-color: #161b22; color: #c9d1d9; }
        html[data-theme="dark"] .search-form input[type="text"]:focus,
        html[data-theme="dark"] .category-filter select:focus { border-color: #58a6ff; box-shadow: inset 0 1px 0 rgba(27,31,36,0.075), 0 0 0 3px rgba(88, 166, 255, 0.3); }
        html[data-theme="dark"] .sort-options span { color: #8b949e; }
        html[data-theme="dark"] .sort-options button { background-color: #21262d; color: #c9d1d9; border-color: #30363d; }
        html[data-theme="dark"] .sort-options button:hover { background-color: #30363d; border-color: #8b949e; }
        html[data-theme="dark"] .sort-options button.current-sort { background-color: #58a6ff; color: #ffffff; border-color: #58a6ff; } /* Ensure white text */
        html[data-theme="dark"] .table-wrapper { border-color: #30363d; background-color: #161b22; }
        html[data-theme="dark"] #item-table th,
        html[data-theme="dark"] #item-table td { border-bottom-color: #30363d; }
        html[data-theme="dark"] #item-table th { background-color: #161b22; color: #8b949e; }
        html[data-theme="dark"] #item-table tbody tr:nth-child(even) { background-color: #1a1f27; }
        html[data-theme="dark"] #item-table tbody tr:hover { background-color: #21262d; }
        html[data-theme="dark"] #item-table tbody tr.selected-item { background-color: #1f6feb; }
        html[data-theme="dark"] #item-table td { color: #c9d1d9; }
        html[data-theme="dark"] #item-table td:nth-child(1) { color: #58a6ff; }
        html[data-theme="dark"] #item-table td:nth-child(1):hover { color: #79c0ff; }
        html[data-theme="dark"] #item-table td:nth-child(2) { color: #8b949e; }
        html[data-theme="dark"] .trend-positive { color: #3fb950; }
        html[data-theme="dark"] .trend-negative { color: #f85149; }
        html[data-theme="dark"] .vendor-price { color: #8b949e; }
        html[data-theme="dark"] .na-value { color: #484f58; }
        html[data-theme="dark"] .chart-display { background-color: #161b22; border-color: #30363d; }
        html[data-theme="dark"] .chart-controls button { background-color: #21262d; color: #c9d1d9; border-color: #30363d; }
        html[data-theme="dark"] .chart-controls button:hover { background-color: #30363d; border-color: #8b949e; }
        html[data-theme="dark"] .chart-controls button.active { background-color: #58a6ff; color: #ffffff; border-color: #58a6ff; } /* Ensure white text */
        html[data-theme="dark"] .chart-placeholder { color: #6e7681; }
        html[data-theme="dark"] .pagination button { background-color: #21262d; border-color: #30363d; color: #58a6ff; }
        html[data-theme="dark"] .pagination button:hover:not(:disabled) { background-color: #30363d; border-color: #8b949e; }
        html[data-theme="dark"] .pagination button.current { background-color: #58a6ff; color: #ffffff; border-color: #58a6ff; } /* Ensure white text */
        html[data-theme="dark"] .pagination button:disabled { color: #484f58; background-color: #21262d; }
        html[data-theme="dark"] .loading-message,
        html[data-theme="dark"] .error-message { color: #8b949e; }
        html[data-theme="dark"] .error-message { color: #f85149; }
        html[data-theme="dark"] footer { color: #8b949e; border-top-color: #30363d; }
        html[data-theme="dark"] footer span,
        html[data-theme="dark"] footer a { color: #8b949e; }
        html[data-theme="dark"] footer a:hover { color: #79c0ff; }

        /* --- Theme Toggle Button Styling (Fixed at bottom) --- */
        .theme-toggle-container {
            position: fixed; bottom: 20px; left: 50%;
            transform: translateX(-50%); z-index: 1000;
        }
        #theme-toggle {
            padding: 8px 15px; background-color: #f6f8fa; color: #24292f; /* Light mode button colors */
            border-radius: 9999px; font-size: 0.9em;
            transition: background-color 0.1s ease-in-out, border-color 0.1s ease-in-out, color 0.1s ease-in-out, box-shadow 0.1s ease-in-out;
            border: 1px solid rgba(27, 31, 36, 0.15);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            cursor: pointer; font-weight: 500; line-height: 20px;
            display: inline-flex; align-items: center; justify-content: center; min-width: 40px;
        }
        #theme-toggle:hover {
             background-color: #f0f2f4; border-color: rgba(27, 31, 36, 0.35);
             box-shadow: 0 3px 7px rgba(0,0,0,0.15);
        }
        /* Dark mode button overrides */
        html[data-theme="dark"] #theme-toggle {
             background-color: #21262d; color: #c9d1d9; border-color: #30363d;
        }
         html[data-theme="dark"] #theme-toggle:hover {
             background-color: #30363d; border-color: #8b949e;
        }
        /* Icon visibility */
        #theme-toggle .fa-sun { display: none; }
        #theme-toggle .fa-moon { display: inline-block; }
        html[data-theme="dark"] #theme-toggle .fa-sun { display: inline-block; }
        html[data-theme="dark"] #theme-toggle .fa-moon { display: none; }

    </style>
</head>
<body>

    <div class="container">
        <h1>MWI Market Trends</h1>
        <div class="feedback-link-container">
            <a href="https://github.com/SporkSlinger/market-tracker-mwi/issues" target="_blank" rel="noopener noreferrer">Report an Issue or Suggest a Feature</a>
        </div>

        <div class="controls">
            <div class="controls-left">
                 <div class="search-form">
                    <input type="text" id="search-input" placeholder="Search Product Name...">
                </div>
                <div class="category-filter">
                     <select id="category-filter">
                         <option value="All">All Categories</option>
                         {% for category in categories %}
                         <option value="{{ category }}">{{ category }}</option>
                         {% endfor %}
                     </select>
                </div>
            </div>
            <div class="controls-right">
                 <div class="sort-options" id="sort-options">
                    <span>Sort By:</span>
                    <button data-sort="name_asc" class="current-sort">Name</button>
                    <button data-sort="category_asc">Category</button>
                    <button data-sort="buy_desc">Buy</button>
                    <button data-sort="ask_asc">Ask</button>
                    <button data-sort="vendor_desc">Vendor</button>
                    <button data-sort="trend_dec">Trend %</button>
                 </div>
            </div>
        </div>

        <div class="main-layout">
            <div class="item-table-container">
                <div id="loading-message" class="loading-message">Loading market data...</div>
                <div id="error-message" class="error-message hidden"></div>
                <div class="table-wrapper hidden">
                    <table id="item-table">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Category</th>
                                <th>Buy</th>
                                <th>Ask</th>
                                <th>Vendor</th>
                                <th>Trend (24h)</th>
                            </tr>
                        </thead>
                        <tbody id="item-table-body"></tbody>
                    </table>
                </div>
                <div class="pagination" id="pagination" style="display: none;">
                    <button id="prev-page" disabled>&laquo; Previous</button>
                    <span id="page-info">Page 1 of 1</span>
                    <button id="next-page" disabled>Next &raquo;</button>
                </div>
            </div>

            <div class="chart-display-container">
                <div class="chart-display" id="chart-display">
                     <div class="chart-controls" id="chart-time-controls" style="display: none;">
                         <button data-range="24h">24h</button>
                         <button data-range="48h">48h</button>
                         <button data-range="7d">7d</button>
                         <button data-range="30d" class="active">30d</button>
                     </div>
                    <div class="chart-placeholder" id="chart-placeholder">Select an item name from the table to view its chart.</div>
                    <div class="chart-plot hidden">
                        <canvas id="single-chart-canvas"></canvas>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <footer>
        <span>Made by Sporky with AI</span> |
        <span class="status">Data Generated: <span id="last-update">{{ last_update }}</span></span> |
        <a href="https://github.com/SporkSlinger/market-tracker-mwi" target="_blank" rel="noopener noreferrer">GitHub Repo</a>
    </footer>

     <div class="theme-toggle-container">
         <button id="theme-toggle" title="Toggle Theme">
             <i class="fas fa-moon"></i><i class="fas fa-sun"></i>
         </button>
    </div>


    <script>
        // --- Global State (Original) ---
        let allMarketData = {}; // Expecting nested object: { "Product": { buy: [...], ask: [...] } }
        let marketSummary = []; // Array of { name, category, buy, ask, vendor, trend }
        let filteredAndSortedSummary = []; // Items currently displayed in table
        let currentChart = null;
        let currentPage = 1;
        const itemsPerPage = 20;
        let currentSort = 'name_asc';
        let currentSearch = '';
        let currentCategoryFilter = 'All';
        let selectedTableRow = null;
        let currentChartProduct = null;
        let currentChartTimeRange = '30d';

        // --- DOM Elements (Original + Theme Toggle) ---
        const tableBodyEl = document.getElementById('item-table-body');
        const tableWrapperEl = document.querySelector('.table-wrapper');
        const paginationEl = document.getElementById('pagination');
        const pageInfoEl = document.getElementById('page-info');
        const prevButton = document.getElementById('prev-page');
        const nextButton = document.getElementById('next-page');
        const searchInput = document.getElementById('search-input');
        const categoryFilterEl = document.getElementById('category-filter');
        const sortOptionsEl = document.getElementById('sort-options');
        const chartCanvas = document.getElementById('single-chart-canvas');
        const chartPlotContainer = document.querySelector('.chart-plot');
        const chartPlaceholder = document.getElementById('chart-placeholder');
        const chartTimeControlsEl = document.getElementById('chart-time-controls');
        const loadingMessageEl = document.getElementById('loading-message');
        const errorMessageEl = document.getElementById('error-message');
        const themeToggleButton = document.getElementById('theme-toggle'); // Added

        // --- SVG Icons for Trends (Original) ---
        const trendUpIcon = `<svg class="trend-icon" aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true"><path fill="currentColor" d="M8.707 2.293a1 1 0 0 0-1.414 0l-4 4a1 1 0 1 0 1.414 1.414L8 4.414l3.293 3.293a1 1 0 0 0 1.414-1.414l-4-4Z"></path></svg>`;
        const trendDownIcon = `<svg class="trend-icon" aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16" data-view-component="true"><path fill="currentColor" d="M7.293 13.707a1 1 0 0 0 1.414 0l4-4a1 1 0 0 0-1.414-1.414L8 11.586 4.707 8.293a1 1 0 0 0-1.414 1.414l4 4Z"></path></svg>`;

        // --- Utility Functions (Original) ---
        function formatPrice(price) {
            if (price === null || price === undefined || isNaN(price)) return '<span class="na-value">--</span>';
            return price.toLocaleString();
        }
        function formatTrend(trend) {
            if (trend === null || trend === undefined || isNaN(trend)) return '<span class="na-value">--</span>';
            const arrow = trend > 0 ? trendUpIcon : trend < 0 ? trendDownIcon : '';
            const trendClass = trend > 0 ? 'trend-positive' : trend < 0 ? 'trend-negative' : '';
            return `<span class="trend-value-container ${trendClass}">${arrow}<span>${trend.toFixed(2)}%</span></span>`;
        }

        // --- Theme Switching Logic (Added - Basic) ---
        const THEME_KEY = 'mwi-market-theme';
        function applyTheme(theme) {
            // Sets the attribute and saves to localStorage
            if (theme === 'dark') {
                document.documentElement.setAttribute('data-theme', 'dark');
            } else {
                document.documentElement.removeAttribute('data-theme');
            }
            localStorage.setItem(THEME_KEY, theme);
            // Does NOT interact with the chart JS
        }
        function toggleTheme() {
            const currentTheme = document.documentElement.hasAttribute('data-theme') ? 'dark' : 'light';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            applyTheme(newTheme);
        }
        function initTheme() {
            const savedTheme = localStorage.getItem(THEME_KEY);
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            const initialTheme = savedTheme || (prefersDark ? 'dark' : 'light');
            applyTheme(initialTheme);
        }
        // Add listener for the theme toggle button
        if (themeToggleButton) {
             themeToggleButton.addEventListener('click', toggleTheme);
        } else {
             console.error("Theme toggle button not found!");
        }


        // --- Data Fetching (Original - Untouched) ---
        async function loadData() {
            try {
                loadingMessageEl.style.display = 'block';
                errorMessageEl.classList.add('hidden');
                tableWrapperEl.classList.add('hidden');
                paginationEl.style.display = 'none';

                const summaryRes = await fetch('./data/market_summary.json?t=' + Date.now());
                if (!summaryRes.ok) throw new Error(`Failed to fetch market_summary.json (Status: ${summaryRes.status})`);
                marketSummary = await summaryRes.json();

                applyFiltersAndSort();
                loadingMessageEl.style.display = 'none';
                tableWrapperEl.classList.remove('hidden');
                paginationEl.style.display = 'flex';

                const historyRes = await fetch('./data/market_history.json?t=' + Date.now());
                if (!historyRes.ok) {
                    console.warn(`Failed to fetch market_history.json (Status: ${historyRes.status}). Charts may not work.`);
                    allMarketData = {};
                } else {
                    allMarketData = await historyRes.json(); // Assumes nested structure
                    console.log("Market history data loaded.");
                }

            } catch (error) {
                console.error("Error loading data:", error);
                loadingMessageEl.style.display = 'none';
                errorMessageEl.textContent = `Error loading market data: ${error.message}. Check console (F12) & data files.`;
                errorMessageEl.classList.remove('hidden');
            }
        }

        // --- Filtering and Sorting (Original - Untouched) ---
        function applyFiltersAndSort() {
            let result = [...marketSummary];
            if (currentCategoryFilter !== 'All') {
                result = result.filter(item => item.category === currentCategoryFilter);
            }
            const searchTerm = currentSearch.toLowerCase();
            if (searchTerm) {
                result = result.filter(item => item.name.toLowerCase().includes(searchTerm));
            }
            result.sort((a, b) => {
                try {
                    const sortNum = (valA, valB, ascending = true) => {
                        const numA = valA ?? (ascending ? Infinity : -Infinity);
                        const numB = valB ?? (ascending ? Infinity : -Infinity);
                        if (isNaN(numA)) return ascending ? 1 : -1;
                        if (isNaN(numB)) return ascending ? -1 : 1;
                        return ascending ? numA - numB : numB - numA;
                    };
                    const sortStr = (valA, valB, ascending = true) => {
                        const strA = (valA ?? '').toLowerCase(); const strB = (valB ?? '').toLowerCase();
                        const compare = strA.localeCompare(strB);
                        return ascending ? compare : -compare;
                    };
                    switch (currentSort) {
                        case 'name_desc': return sortStr(a.name, b.name, false);
                        case 'category_asc': return sortStr(a.category, b.category, true);
                        case 'buy_desc': return sortNum(a.buy, b.buy, false);
                        case 'ask_asc': return sortNum(a.ask, b.ask, true);
                        case 'vendor_desc': return sortNum(a.vendor, b.vendor, false);
                        case 'trend_inc': return sortNum(a.trend, b.trend, true);
                        case 'trend_dec': return sortNum(a.trend, b.trend, false);
                        case 'name_asc': default: return sortStr(a.name, b.name, true);
                    }
                } catch (e) { console.error("Sort comparison error:", e); return 0; }
            });
            filteredAndSortedSummary = result;
            currentPage = 1;
            renderCurrentPage();
        }

        // --- Rendering (Original - Untouched) ---
        function renderCurrentPage() {
            tableBodyEl.innerHTML = '';
            if (selectedTableRow) {
                selectedTableRow.classList.remove('selected-item');
                selectedTableRow = null;
            }
            if (currentChartProduct) {
                 const stillVisible = filteredAndSortedSummary.slice((currentPage - 1) * itemsPerPage, currentPage * itemsPerPage)
                                     .some(item => item.name === currentChartProduct);
                 if (!stillVisible) { /* Keep chart, deselect row handled below */ }
            }

            const totalItems = filteredAndSortedSummary.length;
            const totalPages = Math.ceil(totalItems / itemsPerPage);
            currentPage = Math.max(1, Math.min(currentPage, totalPages || 1));
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const itemsToDisplay = filteredAndSortedSummary.slice(startIndex, endIndex);

            if (itemsToDisplay.length === 0) {
                 const message = currentSearch || currentCategoryFilter !== 'All' ? 'No items match your filters.' : 'No market data available.';
                 const tr = document.createElement('tr');
                 const td = document.createElement('td');
                 td.colSpan = 6; td.textContent = message; td.style.textAlign = 'center';
                 td.style.padding = '20px'; td.style.color = 'var(--muted-text-color)'; // Use variable now
                 tr.appendChild(td); tableBodyEl.appendChild(tr);
            } else {
                itemsToDisplay.forEach(item => {
                    const tr = document.createElement('tr');
                    tr.dataset.product = encodeURIComponent(item.name);
                    tr.style.cursor = 'pointer';
                    tr.innerHTML = `
                        <td><a>${item.name}</a></td>
                        <td>${item.category || '<span class="na-value">N/A</span>'}</td>
                        <td>${formatPrice(item.buy)}</td>
                        <td>${formatPrice(item.ask)}</td>
                        <td><span class="vendor-price">${formatPrice(item.vendor)}</span></td>
                        <td>${formatTrend(item.trend)}</td>
                    `;
                    tr.addEventListener('click', handleProductClick);
                    tableBodyEl.appendChild(tr);
                    if (item.name === currentChartProduct) {
                         tr.classList.add('selected-item');
                         selectedTableRow = tr;
                    }
                });
            }
            renderPagination(totalPages);
        }

        function renderPagination(totalPages) {
            pageInfoEl.textContent = `Page ${currentPage} of ${totalPages || 1}`;
            prevButton.disabled = currentPage <= 1;
            nextButton.disabled = currentPage >= totalPages;
            paginationEl.style.display = totalPages > 1 ? 'flex' : 'none';
        }

        // --- Charting (Original - Untouched Logic/Options) ---
        function displayChart(productName, clickedTrElement) {
            chartPlaceholder.style.display = 'none';
            chartPlotContainer.classList.remove('hidden');
            chartTimeControlsEl.style.display = 'block';

            if (selectedTableRow) { selectedTableRow.classList.remove('selected-item'); }
            if (clickedTrElement) { clickedTrElement.classList.add('selected-item'); selectedTableRow = clickedTrElement; }
            currentChartProduct = productName;

            const productHistoryData = allMarketData[productName];

            if (!productHistoryData || (!productHistoryData.buy?.length && !productHistoryData.ask?.length)) {
                console.warn(`No chart data found for ${productName} in allMarketData.`);
                if (currentChart) { currentChart.destroy(); currentChart = null; }
                chartPlotContainer.classList.add('hidden');
                chartPlaceholder.textContent = `No price history data available for ${productName}.`;
                chartPlaceholder.style.display = 'flex';
                return;
            }

            let filteredBuy = productHistoryData.buy || [];
            let filteredAsk = productHistoryData.ask || [];
            const now = new Date();
            let startDate;
            let timeUnit = 'day';

            if (currentChartTimeRange === '24h') { startDate = new Date(now.getTime() - (24 * 60 * 60 * 1000)); timeUnit = 'hour'; }
            else if (currentChartTimeRange === '48h') { startDate = new Date(now.getTime() - (2 * 24 * 60 * 60 * 1000)); timeUnit = 'hour'; }
            else if (currentChartTimeRange === '7d') { startDate = new Date(now.getTime() - (7 * 24 * 60 * 60 * 1000)); timeUnit = 'day'; }

            if (startDate) {
                const filterPoints = (points) => points.filter(p => (p.timestamp * 1000) >= startDate.getTime());
                filteredBuy = filterPoints(filteredBuy);
                filteredAsk = filterPoints(filteredAsk);
            }

            if (filteredBuy.length < 1 && filteredAsk.length < 1) {
                 console.warn(`No chart data in range ${currentChartTimeRange} for ${productName}`);
                 if (currentChart) { currentChart.destroy(); currentChart = null; }
                 chartPlotContainer.classList.add('hidden');
                 chartPlaceholder.textContent = `No data available for ${productName} in the selected time range (${currentChartTimeRange}).`;
                 chartPlaceholder.style.display = 'flex';
                 return;
            }

            const parsePoints = (points) => points.map(p => ({ x: new Date(p.timestamp * 1000), y: p.price }));
            const buyData = parsePoints(filteredBuy);
            const askData = parsePoints(filteredAsk);

            const chartData = {
                datasets: [
                    // Original Hardcoded Colors
                    { label: 'Buy', data: buyData, borderColor: '#0969da', backgroundColor: 'rgba(9, 105, 218, 0.1)', tension: 0.1, pointRadius: 1, pointHoverRadius: 4, spanGaps: true, borderWidth: 1.5 },
                    { label: 'Ask', data: askData, borderColor: '#cf222e', backgroundColor: 'rgba(207, 34, 46, 0.1)', tension: 0.1, pointRadius: 1, pointHoverRadius: 4, spanGaps: true, borderWidth: 1.5 }
                ]
            };

            if (currentChart) { currentChart.destroy(); }

            try {
                 // Original Chart Options (Uses hardcoded colors)
                currentChart = new Chart(chartCanvas, {
                    type: 'line',
                    data: chartData,
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        plugins: {
                            title: { display: true, text: `${productName} (${currentChartTimeRange})`, font: { size: 15, weight: '600' }, padding: { bottom: 15 }, color: '#24292f' }, // Hardcoded
                            legend: { position: 'top', labels: { font: { size: 12 }, color: '#24292f' } }, // Hardcoded
                            tooltip: { mode: 'index', intersect: false, bodySpacing: 5, titleSpacing: 6, padding: 10, boxPadding: 4 } // Default tooltip
                        },
                        scales: {
                            x: {
                                type: 'time',
                                time: { unit: timeUnit, tooltipFormat: 'PPp', displayFormats: { hour: 'h:mm a', day: 'MMM d', week: 'MMM d yy' } },
                                title: { display: false },
                                grid: { display: false },
                                ticks: { font: { size: 11 }, color: '#57606a', autoSkip: true, maxRotation: 0, minRotation: 0, maxTicksLimit: 8 } // Hardcoded
                            },
                            y: {
                                type: 'logarithmic', min: 1,
                                title: { display: true, text: 'Price (Log Scale)', font: { size: 12 }, color: '#57606a' }, // Hardcoded
                                grid: { color: '#d0d7de' }, // Hardcoded
                                ticks: { font: { size: 11 }, color: '#57606a', callback: function(value) { /* Log scale tick formatting */ if (value <= 0) return null; if (value >= 1e6) return (value / 1e6).toFixed(1) + 'M'; if (value >= 1e3) return (value / 1e3).toFixed(1) + 'k'; const log10 = Math.log10(value); if (Math.abs(log10 - Math.round(log10)) < 0.01 || value < 10) { return value.toLocaleString(); } return null; } } // Hardcoded
                            }
                        },
                        interaction: { mode: 'index', axis: 'x', intersect: false },
                         animation: { duration: 0 }
                    }
                });
            } catch(e) {
                console.error("Error creating Chart.js instance:", e);
                chartPlotContainer.classList.add('hidden');
                chartPlaceholder.textContent = 'Error rendering chart.';
                chartPlaceholder.style.display = 'flex';
            }
        }


        // --- Event Handlers (Original) ---
        function handleProductClick(event) {
            const clickedTr = event.currentTarget;
            const productName = decodeURIComponent(clickedTr.dataset.product);
            displayChart(productName, clickedTr);
        }
        let searchTimeout;
        searchInput.addEventListener('input', (event) => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                currentSearch = event.target.value;
                applyFiltersAndSort();
            }, 300);
        });
        categoryFilterEl.addEventListener('change', (event) => {
             currentCategoryFilter = event.target.value;
             applyFiltersAndSort();
        });
        sortOptionsEl.addEventListener('click', (event) => {
            if (event.target.tagName === 'BUTTON' && event.target.dataset.sort) {
                const newSort = event.target.dataset.sort;
                if (newSort === currentSort) {
                    if (currentSort === 'name_asc') currentSort = 'name_desc';
                    else if (currentSort === 'name_desc') currentSort = 'name_asc';
                } else { currentSort = newSort; }
                sortOptionsEl.querySelectorAll('button').forEach(btn => {
                    btn.classList.toggle('current-sort', btn.dataset.sort === currentSort);
                });
                applyFiltersAndSort();
            }
        });
        prevButton.addEventListener('click', () => {
            if (currentPage > 1) { currentPage--; renderCurrentPage(); }
        });
        nextButton.addEventListener('click', () => {
            const totalPages = Math.ceil(filteredAndSortedSummary.length / itemsPerPage);
            if (currentPage < totalPages) { currentPage++; renderCurrentPage(); }
        });
        chartTimeControlsEl.addEventListener('click', (event) => {
            if (event.target.tagName === 'BUTTON' && event.target.dataset.range) {
                const newRange = event.target.dataset.range;
                if (newRange !== currentChartTimeRange) {
                    currentChartTimeRange = newRange;
                    chartTimeControlsEl.querySelectorAll('button').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.range === currentChartTimeRange);
                    });
                    if (currentChartProduct) {
                        displayChart(currentChartProduct, selectedTableRow); // Re-render chart
                    }
                }
            }
        });

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', () => {
            // initTheme(); // **REMOVED** theme init call from here
            loadData(); // Load data
        });

    </script>

</body>
</html>
```
Most up-to-date Immersive Artifact for "python_file_1" is:

```python
import os
import sqlite3
import json
import requests
import pandas as pd
import numpy as np # Import numpy for NaN/Inf checking/replacement
from datetime import datetime, timedelta, timezone # Import timezone
import logging
import math
import shutil
from jinja2 import Environment, FileSystemLoader # For rendering HTML template

# --- Configuration --
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - [%(funcName)s] %(message)s')

# Source Data URLs and Paths
DB_URL = "https://raw.githubusercontent.com/holychikenz/MWIApi/main/market.db"
JSON_URL = "https://raw.githubusercontent.com/holychikenz/MWIApi/main/milkyapi.json"
DB_PATH = "market.db" # Downloaded file paths
JSON_PATH = "milkyapi.json"
CATEGORY_FILE_PATH = "cata.txt" # Path to your category file

# Output directory for static files
OUTPUT_DIR = "output"
OUTPUT_DATA_DIR = os.path.join(OUTPUT_DIR, "data") # Subdir for data files
TEMPLATE_DIR = "templates" # Directory for Jinja templates - Added for clarity

# History and Trend Settings
HISTORICAL_DAYS = 30 # How much history to process
TREND_WINDOW_HOURS = 12 # +/- hours around 24h ago for trend calc

# --- Category Parsing (Revised v3 - Based on new cata.txt) ---
# (parse_categories function remains the same as provided by user)
def parse_categories(filepath):
    """Parses the cata.txt file into a dictionary {item_name: category}."""
    categories = {}
    current_main_category = "Unknown"
    current_sub_category = None
    current_display_category = "Unknown" # Category name to assign to items

    # Define known main categories and subcategories from the new file structure
    known_main_categories = [
        "Currencies", "Loots", "Resources", "Consumables", "Books", "Keys",
        "Equipment", "Jewelry", "Trinket", "Tools"
    ]
    equipment_subcategories = [
        "Main Hand", "Off Hand", "Head", "Body", "Legs", "Hands", # Renamed from Gloves
        "Feet", "Back", "Pouch"
    ]
    # Note: Jewelry is now a main category according to the file structure
    tool_subcategories = [
        "Milking", "Foraging", "Woodcutting", "Cheesesmithing", "Crafting",
        "Tailoring", "Cooking", "Brewing", "Alchemy", "Enhancing"
    ]

    logging.info(f"Attempting to parse category file: {filepath}")
    try:
        with open(filepath, 'r', encoding='utf-8') as f:
            for line_num, line in enumerate(f, 1):
                line = line.strip()
                # Skip empty lines and potential separators
                if not line or line == 'â€¢':
                    continue

                logging.debug(f"Processing Line {line_num}: '{line}'")

                # Check if it's a known main category
                if line in known_main_categories:
                    current_main_category = line
                    current_sub_category = None # Reset subcategory
                    current_display_category = current_main_category # Assign main category by default
                    logging.debug(f"  -> Matched Main Category: {current_main_category}")
                    continue # Move to next line

                # Check if it's an equipment subcategory
                if current_main_category == "Equipment" and line in equipment_subcategories:
                    current_sub_category = line
                    current_display_category = f"Equipment / {current_sub_category}"
                    logging.debug(f"  -> Matched Equipment Sub Category: {current_sub_category} -> Display: {current_display_category}")
                    continue # Move to next line

                # Check if it's a tool subcategory
                if current_main_category == "Tools" and line in tool_subcategories:
                    current_sub_category = line
                    current_display_category = f"Tools / {current_sub_category}"
                    logging.debug(f"  -> Matched Tool Sub Category: {current_sub_category} -> Display: {current_display_category}")
                    continue # Move to next line

                # Otherwise, assume it's a line containing item(s)
                # Split by comma, strip whitespace from each item
                item_names = [name.strip() for name in line.split(',') if name.strip()]

                if not item_names:
                    logging.warning(f"  -> Line {line_num} parsed as empty item list: '{line}'")
                    continue

                for item_name in item_names:
                    if item_name: # Ensure not empty after stripping
                        # Assign the current display category
                        # Handle edge case where an item might appear before any category header
                        if current_display_category == "Unknown" and current_main_category != "Unknown":
                             current_display_category = current_main_category

                        categories[item_name] = current_display_category
                        logging.debug(f"  -> Found Item: '{item_name}' -> '{current_display_category}'")
                    else:
                         logging.warning(f"  -> Found empty item name after split/strip on line {line_num}: '{line}'")


        logging.info(f"Parsed {len(categories)} items from category file.")
        # Log a sample for verification
        sample_items = list(categories.items())[:5] + list(categories.items())[-5:]
        logging.debug(f"Category parsing sample (first/last 5): {sample_items}")
        # Log specific items if needed for debugging
        logging.debug(f"Category for 'Necklace Of Efficiency': {categories.get('Necklace Of Efficiency')}")
        logging.debug(f"Category for 'Cheese Brush': {categories.get('Cheese Brush')}")
        logging.debug(f"Category for 'Rough Hide': {categories.get('Rough Hide')}")
        return categories
    except FileNotFoundError:
        logging.error(f"Category file not found at {filepath}. Categories will be missing.")
        return {}
    except Exception as e:
        logging.error(f"Error parsing category file {filepath}: {e}", exc_info=True)
        return {}


# --- Data Fetching ---
# (download_file function remains the same as provided by user)
def download_file(url, local_path):
    logging.info(f"Attempting to download {url} to {local_path}")
    try:
        response = requests.get(url, stream=True, timeout=60)
        response.raise_for_status()
        with open(local_path, 'wb') as f:
            for chunk in response.iter_content(chunk_size=8192): f.write(chunk)
        logging.info(f"Successfully downloaded {local_path}")
        return True
    except Exception as e: logging.error(f"Error downloading {url}: {e}"); return False

# --- Data Loading and Processing ---
# (load_historical_data function remains the same as provided by user)
def load_historical_data(days_to_load):
    logging.info(f"Loading historical data for {days_to_load} days from {DB_PATH}")
    if not os.path.exists(DB_PATH): logging.warning(f"{DB_PATH} not found."); return pd.DataFrame()
    conn = None
    try:
        conn = sqlite3.connect(DB_PATH)
        cutoff_timestamp = (datetime.now() - timedelta(days=days_to_load)).timestamp()
        ask_query = "SELECT * FROM ask WHERE time >= ?"; ask_df_wide = pd.read_sql_query(ask_query, conn, params=(cutoff_timestamp,))
        bid_query = "SELECT * FROM bid WHERE time >= ?"; bid_df_wide = pd.read_sql_query(bid_query, conn, params=(cutoff_timestamp,))
        conn.close(); conn = None
        logging.info(f"DB Query: Loaded {len(ask_df_wide)} wide ask, {len(bid_df_wide)} wide bid records.")
        if ask_df_wide.empty and bid_df_wide.empty: return pd.DataFrame()
        ask_df_long = pd.DataFrame()
        if not ask_df_wide.empty and 'time' in ask_df_wide.columns:
            item_columns_ask = [col for col in ask_df_wide.columns if col.lower() != 'time']
            if item_columns_ask:
                try:
                    logging.info(f"Melting 'ask' table ({len(ask_df_wide)} rows)...")
                    ask_df_long = ask_df_wide.melt(id_vars=['time'], value_vars=item_columns_ask, var_name='product', value_name='ask')
                    ask_df_long['timestamp'] = pd.to_datetime(ask_df_long['time'], unit='s', errors='coerce')
                    ask_df_long['ask'] = pd.to_numeric(ask_df_long['ask'], errors='coerce')
                    ask_df_long.drop(columns=['time'], inplace=True); ask_df_long.dropna(subset=['timestamp', 'ask'], inplace=True)
                    ask_df_long = ask_df_long[['product', 'ask', 'timestamp']]
                except Exception as melt_error: logging.error(f"Error melting 'ask' data: {melt_error}", exc_info=True)
            else: logging.warning("No item columns found in 'ask' table.")
        del ask_df_wide
        bid_df_long = pd.DataFrame()
        if not bid_df_wide.empty and 'time' in bid_df_wide.columns:
            item_columns_bid = [col for col in bid_df_wide.columns if col.lower() != 'time']
            if item_columns_bid:
                try:
                    logging.info(f"Melting 'bid' table ({len(bid_df_wide)} rows)...")
                    bid_df_long = bid_df_wide.melt(id_vars=['time'], value_vars=item_columns_bid, var_name='product', value_name='buy')
                    bid_df_long['timestamp'] = pd.to_datetime(bid_df_long['time'], unit='s', errors='coerce')
                    bid_df_long['buy'] = pd.to_numeric(bid_df_long['buy'], errors='coerce')
                    bid_df_long.drop(columns=['time'], inplace=True); bid_df_long.dropna(subset=['timestamp', 'buy'], inplace=True)
                    bid_df_long = bid_df_long[['product', 'buy', 'timestamp']]
                except Exception as melt_error: logging.error(f"Error melting 'bid' data: {melt_error}", exc_info=True)
            else: logging.warning("No item columns found in 'bid' table.")
        del bid_df_wide
        logging.info("Merging melted ask and bid data...")
        if not ask_df_long.empty and not bid_df_long.empty: merged_df = pd.merge(ask_df_long, bid_df_long, on=['product', 'timestamp'], how='outer')
        elif not ask_df_long.empty: merged_df = ask_df_long.copy(); merged_df['buy'] = pd.NA
        elif not bid_df_long.empty: merged_df = bid_df_long.copy(); merged_df['ask'] = pd.NA
        else: merged_df = pd.DataFrame()
        del ask_df_long, bid_df_long
        if not merged_df.empty:
             logging.info(f"Sorting merged data ({len(merged_df)} records)...")
             merged_df.sort_values(by=['product', 'timestamp'], inplace=True)
             final_cols = ['product', 'buy', 'ask', 'timestamp']
             for col in final_cols:
                 if col not in merged_df.columns: merged_df[col] = pd.NA
             merged_df = merged_df[final_cols]
        logging.info(f"Finished historical data processing. Records: {len(merged_df)}")
        return merged_df
    except Exception as e:
        logging.error(f"Error loading/processing historical data: {e}", exc_info=True)
        if conn: conn.close()
        return pd.DataFrame()

# (load_live_data function remains the same as provided by user)
def load_live_data():
    logging.info(f"Loading live data from {JSON_PATH}")
    vendor_prices = {}; live_records_df = pd.DataFrame()
    if not os.path.exists(JSON_PATH): logging.warning(f"{JSON_PATH} not found."); return live_records_df, vendor_prices
    try:
        with open(JSON_PATH, 'r') as f: data = json.load(f)
        if 'market' not in data or not isinstance(data['market'], dict): logging.error("Invalid JSON structure."); return live_records_df, vendor_prices
        market_data = data['market']; records = []
        current_time = datetime.now()
        for product_name, price_info in market_data.items():
            if isinstance(price_info, dict) and 'ask' in price_info and 'bid' in price_info:
                 ask_price = pd.NA if price_info['ask'] == -1 else price_info['ask']
                 buy_price = pd.NA if price_info['bid'] == -1 else price_info['bid']
                 vendor_price = price_info.get('vendor', pd.NA)
                 records.append({'product': product_name, 'buy': buy_price, 'ask': ask_price, 'timestamp': current_time})
                 if vendor_price == -1 or vendor_price is None: vendor_prices[product_name] = None
                 else:
                     try: vendor_prices[product_name] = int(vendor_price)
                     except (ValueError, TypeError): vendor_prices[product_name] = None
            else: logging.warning(f"Skipping invalid JSON item: {product_name}")
        if records:
            live_records_df = pd.DataFrame(records)
            live_records_df['buy'] = pd.to_numeric(live_records_df['buy'], errors='coerce')
            live_records_df['ask'] = pd.to_numeric(live_records_df['ask'], errors='coerce')
            live_records_df['timestamp'] = pd.to_datetime(live_records_df['timestamp'], errors='coerce')
            live_records_df.dropna(subset=['timestamp'], inplace=True)
            live_records_df = live_records_df[['product', 'buy', 'ask', 'timestamp']]
        logging.info(f"Loaded {len(live_records_df)} live records and {len(vendor_prices)} vendor prices.")
        return live_records_df, vendor_prices
    except Exception as e: logging.error(f"Error loading live data: {e}", exc_info=True); return pd.DataFrame(), {}

# (calculate_trends function remains the same as provided by user)
def calculate_trends(df, products):
    trends = {}; processed_count = 0
    if df.empty or not products: return trends
    now = datetime.now(); yesterday = now - timedelta(hours=24)
    yesterday_start = yesterday - timedelta(hours=TREND_WINDOW_HOURS); yesterday_end = yesterday + timedelta(hours=TREND_WINDOW_HOURS)
    logging.info(f"Calculating trends for {len(products)} products relative to {yesterday.strftime('%Y-%m-%d %H:%M:%S')}")
    try:
        df['timestamp'] = pd.to_datetime(df['timestamp'], errors='coerce')
        df.dropna(subset=['timestamp'], inplace=True)
        if df.empty: return trends
    except Exception as e: logging.error(f"Error converting timestamp for trend calc: {e}"); return trends
    df['avg_price'] = df[['buy', 'ask']].mean(axis=1).fillna(df['buy']).fillna(df['ask'])
    relevant_past_data = df[df['timestamp'] <= yesterday_end].copy()
    grouped = df.groupby('product')
    relevant_past_grouped = relevant_past_data.groupby('product')
    for product in products:
        try:
            product_group = grouped.get_group(product)
            if product_group.empty: continue
            latest_data = product_group.iloc[-1]; current_price = latest_data['avg_price']
            if pd.isna(current_price): continue
            if product not in relevant_past_grouped.groups: continue
            past_product_df = relevant_past_grouped.get_group(product)
            past_window_df = past_product_df[(past_product_df['timestamp'] >= yesterday_start)]
            if past_window_df.empty: continue
            time_diff_series = (past_window_df['timestamp'] - yesterday).abs()
            if time_diff_series.empty: continue
            closest_index_label = time_diff_series.idxmin()
            closest_past_data = past_window_df.loc[closest_index_label]
            previous_price = closest_past_data['avg_price']
            if pd.isna(previous_price): continue
            if previous_price != 0:
                 change_pct = ((current_price - previous_price) / previous_price) * 100; trends[product] = change_pct
                 processed_count += 1
            else: trends[product] = None
        except KeyError: continue
        except Exception as e: logging.error(f"Error calculating trend for {product}: {e}", exc_info=True); continue
    logging.info(f"Finished trend calculation. Calculated trends for {processed_count} out of {len(products)} products.")
    return {k: (v if pd.notna(v) and np.isfinite(v) else None) for k, v in trends.items()}

def main():
    """Main build process."""
    logging.info("--- Starting Static Site Build ---")
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    os.makedirs(OUTPUT_DATA_DIR, exist_ok=True)
    logging.info(f"Output directory '{OUTPUT_DIR}' ensured.")

    # --- Parse Categories ---
    item_categories = parse_categories(CATEGORY_FILE_PATH)
    if not item_categories:
        logging.warning("Category data is empty or failed to load. Categories will be missing in output.")

    # --- Download and Load Data ---
    db_ok = download_file(DB_URL, DB_PATH)
    json_ok = download_file(JSON_URL, JSON_PATH)
    if not json_ok: logging.error("Failed to download milkyapi.json. Cannot proceed."); return
    if not db_ok: logging.warning("Failed to download market.db. Historical data may be missing.")

    historical_df = load_historical_data(days_to_load=HISTORICAL_DAYS)
    live_df, vendor_prices = load_live_data()

    if historical_df.empty and live_df.empty:
         logging.error("Both historical and live data are empty. Cannot build site.")
         combined_df = pd.DataFrame()
    else:
         logging.info("Concatenating historical and live data...")
         combined_df = pd.concat([historical_df, live_df], ignore_index=True)

    if not combined_df.empty:
        logging.info(f"Processing combined data ({len(combined_df)} records)...")
        combined_df.drop_duplicates(subset=['product', 'timestamp'], keep='last', inplace=True)
        combined_df.sort_values(by=['product', 'timestamp'], inplace=True)
        combined_df['buy'] = pd.to_numeric(combined_df['buy'], errors='coerce')
        combined_df['ask'] = pd.to_numeric(combined_df['ask'], errors='coerce')
        combined_df['timestamp'] = pd.to_datetime(combined_df['timestamp'], errors='coerce')
        combined_df.dropna(subset=['timestamp'], inplace=True)
        logging.info(f"Final processed data size: {len(combined_df)} records.")
    else:
        logging.warning("Combined data is empty after processing.")

    all_products = sorted(list(combined_df['product'].unique())) if not combined_df.empty else []
    product_trends = calculate_trends(combined_df.copy(), all_products) # Use copy

    # --- Generate JSON Data Files ---
    logging.info("Generating JSON data files...")

    # 1. Market Summary (Includes category now)
    market_summary = []
    if not combined_df.empty:
        latest_data_map = combined_df.groupby('product').last()
        for product in all_products:
            if product in latest_data_map.index:
                latest = latest_data_map.loc[product]
                market_summary.append({
                    'name': product,
                    'category': item_categories.get(product, 'Unknown'),
                    'buy': latest['buy'] if pd.notna(latest['buy']) else None,
                    'ask': latest['ask'] if pd.notna(latest['ask']) else None,
                    'vendor': vendor_prices.get(product),
                    'trend': product_trends.get(product)
                })
            else:
                 logging.warning(f"Product '{product}' not found in latest_data_map despite being in unique list.")

    summary_path = os.path.join(OUTPUT_DATA_DIR, 'market_summary.json')
    try:
        with open(summary_path, 'w') as f:
            json.dump(market_summary, f, allow_nan=False)
        logging.info(f"Saved market summary to {summary_path}")
    except ValueError as ve: logging.error(f"ValueError saving market summary JSON: {ve}")
    except Exception as e: logging.error(f"Failed to save market summary JSON: {e}")


    # 2. Full Historical Data - MODIFIED TO OUTPUT NESTED OBJECT
    nested_history_dict = {}
    if not combined_df.empty:
        logging.info("Grouping historical data by product for nested JSON...")
        # Ensure timestamp is datetime for calculations
        if not pd.api.types.is_datetime64_any_dtype(combined_df['timestamp']):
             combined_df['timestamp'] = pd.to_datetime(combined_df['timestamp'], errors='coerce')
             combined_df.dropna(subset=['timestamp'], inplace=True) # Drop rows where conversion failed

        # Convert timestamp to UTC if it doesn't have timezone info
        # This ensures consistent epoch seconds regardless of server timezone
        if combined_df['timestamp'].dt.tz is None:
            combined_df['timestamp'] = combined_df['timestamp'].dt.tz_localize('UTC')
        else:
            combined_df['timestamp'] = combined_df['timestamp'].dt.tz_convert('UTC')

        # Group by product
        grouped_history = combined_df.groupby('product')

        for product_name, group_df in grouped_history:
            buy_list = []
            ask_list = []

            # Process buy data for the product
            buy_data = group_df[['timestamp', 'buy']].dropna(subset=['buy'])
            if not buy_data.empty:
                 buy_list = [
                     {"timestamp": int(ts.timestamp()), "price": price}
                     for ts, price in zip(buy_data['timestamp'], buy_data['buy'])
                     if pd.notna(price) and np.isfinite(price) # Ensure price is valid number
                 ]

            # Process ask data for the product
            ask_data = group_df[['timestamp', 'ask']].dropna(subset=['ask'])
            if not ask_data.empty:
                 ask_list = [
                     {"timestamp": int(ts.timestamp()), "price": price}
                     for ts, price in zip(ask_data['timestamp'], ask_data['ask'])
                     if pd.notna(price) and np.isfinite(price) # Ensure price is valid number
                 ]

            # Only add product if it has at least one buy or ask point
            if buy_list or ask_list:
                 nested_history_dict[product_name] = {"buy": buy_list, "ask": ask_list}

    # Save the nested dictionary
    history_path = os.path.join(OUTPUT_DATA_DIR, 'market_history.json')
    try:
        logging.info(f"Attempting to save nested market history JSON ({len(nested_history_dict)} products)...")
        with open(history_path, 'w') as f:
            json.dump(nested_history_dict, f, allow_nan=False) # allow_nan=False handles residual issues
        logging.info(f"Saved nested market history to {history_path}")
    except ValueError as ve:
        logging.error(f"ValueError saving market history JSON: {ve}")
        # Add more detailed logging for complex structures if needed
    except Exception as e:
        logging.error(f"Failed to save market history JSON: {e}")


    # --- Render HTML Template ---
    logging.info("Rendering HTML template...")
    try:
        # Get unique categories for the filter dropdown FROM THE PARSED DATA
        unique_categories = sorted(list(set(item_categories.values()))) if item_categories else []

        # Ensure TEMPLATE_DIR is defined correctly
        if not os.path.isdir(TEMPLATE_DIR):
             logging.error(f"Template directory '{TEMPLATE_DIR}' not found!")
             return # Stop if template dir is missing

        env = Environment(loader=FileSystemLoader(TEMPLATE_DIR)) # Use TEMPLATE_DIR
        template = env.get_template('index.html')
        html_context = {
            'last_update': datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'categories': unique_categories # Pass parsed categories
            }
        html_content = template.render(html_context)
        html_path = os.path.join(OUTPUT_DIR, 'index.html')
        with open(html_path, 'w', encoding='utf-8') as f: f.write(html_content)
        logging.info(f"Saved main HTML to {html_path}")
    except Exception as e: logging.error(f"Failed to render or save HTML template: {e}", exc_info=True)

    logging.info("--- Static Site Build Finished ---")

if __name__ == '__main__':
    main()
